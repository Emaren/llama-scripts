#!/usr/bin/env zsh
###############################################################################
#  sanity â€” pragmatic shell-health checklist                              v4.3
#  https://github.com/tonyblum/llama-scripts  (single-file, copy-paste ready)
###############################################################################

###############################################################################
# â–‘â–‘  CLI flags / version
###############################################################################
echo "âœ… Running via: \$0 = $0"
echo "âœ… ZSH Version: ${ZSH_VERSION:-not-zsh}"
VERSION=4.3
usage() {
  cat <<EOF
Usage: $(basename "$0") [options]

  -q               quiet  â€“ hide INFO banners (still prints OK/WARN/FAIL)
  -qq              silent â€“ absolutely no stdout; rely on exit-code (0/1/2)
  --json           emit machine-readable JSON (quiet implied)
  --fix            attempt auto-remediation of failed checks
  --bench          print shell-startup + runtime timings
  --fast           skip slow checks (pyenv doctor, brew update)
  --no-rc          do NOT source ~/.zshrc (handy for CI / cron jobs)
  --direnv-audit     audit .envrc validity + venv presence + .direnv folder size
  -v,  --version   print version and exit
  -h,  --help      this message
EOF
}

QUIET=0 SILENT=0 JSON=0 FIX=0 BENCH=0 SKIP_RC=0 FAST=0
for arg in "$@"; do
  case $arg in
    -q)            QUIET=1 ;;
    -qq)           QUIET=1; SILENT=1 ;;
    --json)        QUIET=1; JSON=1 ;;
    --fix)         FIX=1 ;;
    --bench)       BENCH=1 ;;
    --no-rc)       SKIP_RC=1 ;;
    --fast)        FAST=1 ;;
    --direnv-audit)
      echo "ğŸ“‹ Direnv Audit â€” Checking all projects for valid .envrc + venv..."
      "$HOME/projects/llama-scripts/bin/direnv-audit.sh"
      exit 0 ;;
    -v|--version)  echo "$VERSION"; exit 0 ;;
    -h|--help)     usage; exit 0 ;;
    *)             echo "Unknown flag: $arg"; usage; exit 1 ;;
  esac
done

[[ $SILENT == 1 && $JSON == 1 ]] && { echo "Cannot use --json with -qq"; exit 1; }
[[ $SILENT == 1 ]] && exec >/dev/null

# â¬‡ï¸ New block for llama-status
if [[ "${1:-}" == "direnv-audit" ]]; then
  echo "ğŸ“‹ Direnv Audit â€” Checking all projects for valid .envrc + venv..."
  "$HOME/projects/llama-scripts/bin/direnv-audit.sh"
  exit 0
fi

# complain on unset vars, propagate pipe errors
set -uo pipefail

###############################################################################
# â–‘â–‘  import interactive environment (never abort if RC is broken)
###############################################################################
if [[ $SKIP_RC -eq 0 && -f ~/.zshrc ]]; then
  set +e                              # disable errexit temporarily
  source ~/.zshrc >/dev/null 2>&1 || true
# set -e                              # <- remove: we handle errors ourselves
fi

# minimal env tweaks
export NVM_SILENT=true NVM_INSTALL_COMPLETIONS=false
setopt INTERACTIVE_COMMENTS           # allow # inside heredocs

START_TS=$(date +%s%3N)

# Fallbacks for unset vars in strict mode (set -u)
: "${GRN:=}"
: "${RED:=}"
: "${YLW:=}"
: "${RST:=}"
: "${FAILED:=0}"
: "${WARNED:=0}"
: "${JSON:=0}"
: "${label:=}"

###############################################################################
# â–‘â–‘  colours & helpers
###############################################################################
if [[ -t 1 && $TERM != dumb && $JSON -eq 0 ]]; then
  RED=$'\033[31m'; GRN=$'\033[32m'; YLW=$'\033[33m'; BLU=$'\033[1;34m'; RST=$'\033[0m'
else
  RED= GRN= YLW= BLU= RST=
fi

WARNED=0 FAILED=0
cols()      { tput cols 2>/dev/null || echo 80; }
_line()     { printf 'â”€%.0s' $(seq 1 "$(( ( $(cols)<60?60:$(cols) ) -1 ))"); }
_info()     { (( QUIET )) || { printf '\n%s%s%s\n' "$BLU" "$*" "$RST"; }; }
_divider()  { (( QUIET )) || { printf '\n%s' "$BLU"; _line; printf 'â”€%s\n' "$RST"; }; }
_ok()       { (( QUIET )) || printf '   %sOK%s\n'   "$GRN" "$RST"; \
              [[ $JSON -eq 1 ]] && _emit_json "$label" "OK"; }
_warn()     { printf '   %sWARN%s %s\n' "$YLW" "$RST" "$1"; WARNED=1; \
              [[ $JSON -eq 1 ]] && _emit_json "$label" "WARN" "$1"; }
_fail()     { printf '   %sFAIL%s â† %s\n' "$RED" "$RST" "$1"; FAILED=1; \
              [[ $JSON -eq 1 ]] && _emit_json "$label" "FAIL" "$1"; }
has()       { command -v "$1" &>/dev/null; }
_emit_json(){ printf '{"check":"%s","status":"%s","msg":"%s"}\n' \
              "${1//\"/\\\"}" "${2//\"/\\\"}" "${3:-}"; }

check() {                    # check "Label" 'test-cmd' [warn] [fix]
  label=$1 test=$2 warn=${3:-} fixer=${4:-}
  (( QUIET )) || printf '%-34s â€¦ ' "$label"
  if eval "$test" &>/dev/null; then _ok
  elif [[ -n $warn ]]; then
    _warn "$warn"
    [[ $FIX -eq 1 && -n $fixer ]] && _apply_fix "$fixer"
  else
    _fail "$test"
    [[ $FIX -eq 1 && -n $fixer ]] && _apply_fix "$fixer"
  fi

    (( ${+SLEEP} )) && sleep $SLEEP
}

_apply_fix() {           # _apply_fix "<command to run>"
  local cmd=$1
  local timeout_s=15     # change to taste

  (( QUIET )) || printf '      attempting fix â†’ %s â€¦ ' "$cmd"

  # Run command with timeout; GNU and macOS both have 'command timeout'
  if command -v timeout &>/dev/null; then
    timeout "$timeout_s" bash -c "$cmd" &>/dev/null
  else
    # fallback: run in background and kill after timeout
    bash -c "$cmd" &>/tmp/sanity_fix.$$ &
    local pid=$!
    (sleep "$timeout_s"; kill -0 $pid 2>/dev/null && kill $pid) & disown
    wait $pid 2>/dev/null
  fi

  if [[ $? -eq 0 ]]; then
    (( QUIET )) || printf '%sOK%s\n' "$GRN" "$RST"
  else
    (( QUIET )) || printf '%sFAIL (timed-out)%s\n' "$RED" "$RST"
  fi
}

 probe(){ check "$@"; }  # legacy alias

###############################################################################
# Helper: return success if `brew doctor` only emits ignorable warnings
###############################################################################
_brew_doctor_ok() {
  command -v brew >/dev/null || return 1
  local out
  if command -v timeout >/dev/null; then
    out=$(timeout 15 brew doctor 2>&1 || true)
  else
    out=$(brew doctor 2>&1 || true)
  fi
  echo "$out" | awk '
    BEGIN   {ok=1}
    /^Warning:/ {
      if ($0 ~ /(same name as core formulae|just ignore this)/) next
      ok=0
    }
    END     {exit !ok}
  '
}

###############################################################################
# â–‘â–‘  bootstrap NVM & direnv (silent)
###############################################################################
export NVM_DIR="$HOME/.nvm"
[[ -s "$NVM_DIR/nvm.sh" ]] && . "$NVM_DIR/nvm.sh" >/dev/null
has direnv && eval "$(direnv export bash)" || true

###############################################################################
# â–‘â–‘  SHELL LINT (self)
###############################################################################
if has shellcheck; then
  _divider; _info "ğŸª„  SHELL LINT"
  shellcheck -q "$0" && _ok || _warn 'ShellCheck warnings'
fi
if has shfmt; then
  check "shfmt compliant" 'shfmt -d "$0" | grep -q "^$"' "(run: shfmt -w sanity)"
fi

###############################################################################
# â–‘â–‘  PYTHON TOOLCHAIN
###############################################################################
if has pyenv; then
  _divider; _info "ğŸ  PYTHON TOOLCHAIN"

  # â”€â”€ Optional: skip slow checks in FAST mode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (( FAST )); then
    _info "ğŸ  FAST mode â€“ skipping pyenv doctor"
  else
    probe "pyenv doctor" "pyenv doctor"
  fi

  # â”€â”€ Check Python version â‰¥ 3.12 (major.minor) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  [[ $FAST -eq 1 ]] || \
  probe "python â©¾3.12" 'python - <<PY
import sys; sys.exit(0 if sys.version_info >= (3,12) else 1)
PY' "(upgrade Python)" "pyenv install 3.12.3 && pyenv global 3.12.3"

  # â”€â”€ Check pre-commit version â‰¥ 4.x â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  probe "pre-commit â©¾4" \
        '[[ "$(pre-commit --version 2>/dev/null || true)" =~ " 4[.]" ]]' \
        "(pipx install pre-commit)" "pipx install pre-commit"

  # â”€â”€ Check if pipx is installed and on PATH â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  check "pipx on PATH" 'command -v pipx' \
        "(pipx install pipx && pipx ensurepath)"

  # â”€â”€ Detect whether inside a virtual environment â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  python - <<'PY' && _IN_VENV=true || _IN_VENV=false
import sys; sys.exit(0 if sys.prefix != getattr(sys, "base_prefix", sys.prefix) else 1)
PY

  if $_IN_VENV; then
    probe "interpreter inside venv" true

    # Match pip and python versions (major.minor only)
    PY_VER=$(python --version 2>&1 | awk '{print $2}' | cut -d. -f1,2)
    PIP_VER=$(pip --version 2>&1 | grep -oE 'python [0-9.]+' | awk '{print $2}' | cut -d. -f1,2)

    if [[ "$PIP_VER" == "$PY_VER" ]]; then
      _ok "pip â†” python match"
    else
      _fail "pip â†” python mismatch (python $PY_VER vs pip $PIP_VER)"
    fi

  else
    probe "no venv expected" true
  fi

  # â”€â”€ Ensure PATH has only one pyenv shim segment â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  check "single pyenv shim path" \
        'tr ":" "\n" <<<"$PATH" | grep -c "/.pyenv/shims" | grep -q "^1$"'
else
  _info "ğŸ  Pyenv not installed â€” skipping"
fi

###############################################################################
# â–‘â–‘  NODE / NVM  (hardened for set -e environments)
###############################################################################
if has nvm && nvm --version >/dev/null 2>&1; then
  _divider; _info "ğŸŸ¢  NODE / NVM"

  set +e               # â”€â”€â”€ suspend â€˜exit-on-errorâ€™ just for this block â”€â”€â–¶

  # safest way to resolve the intended â€œdefaultâ€ version
  def_ver=$( nvm version default 2>/dev/null || echo N/A )
  if [[ $def_ver == N/A || -z $def_ver ]]; then
    def_ver=$( nvm version-remote --lts 2>/dev/null || echo N/A )
    [[ $def_ver != N/A ]] && {
      nvm install --silent "$def_ver" &>/dev/null
      nvm alias default "$def_ver"    &>/dev/null
    }
  fi

  # pivot to the default version if current shell isnâ€™t already there
  node_ver=$( node -v 2>/dev/null | tr -d '\n' || echo none )
  [[ $node_ver != "$def_ver" && $def_ver != N/A ]] && \
        nvm use --silent "$def_ver" &>/dev/null || true
  node_ver=$( node -v 2>/dev/null | tr -d '\n' || echo none )

  check "alias default â‡’ $def_ver" '[ "$def_ver" != "N/A" ]'
  check "Node version = default"  '[ "$node_ver" = "$def_ver" ]' "(node $node_ver)"
  check "npm cli present" 'command -v npm'
# set -e               # <- remove
else
  _info "ğŸŸ¢  NVM not installed â€” skipping"
fi

###############################################################################
# â–‘â–‘  ENV MANAGEMENT
###############################################################################
if has direnv; then
  _divider
  _info "âœ¨  ENV MANAGEMENT"  # This header should only be printed once

  # Checking ".envrc allowed" status
  check ".envrc allowed" '[[ -f .envrc ]]'

  # Check if direnv sees pyenv env
  has pyenv && \
    check "direnv sees pyenv env" '[ $(pyenv version-name) != system ]'

  # Check if starship git status is enabled
  check "Starship git_status" 'grep -q "\[git_status\]" ~/.config/starship.toml' "(enable VCS prompt)"

  # âœ… Already verified earlier
  probe "pip â†” python match" true "(verified in Python section)"

  # â–‘â–‘ PATH duplicate check â€” safe and timeout-free â–‘â–‘
  _info "PATH duplicate check"  # This header is now removed from being printed multiple times
  if [[ -n "$(echo "$PATH" | tr ":" "\n" | sort | uniq -d)" ]]; then
    _info "Duplicate PATH segments found, attempting fix"
    # Deduplicate PATH
    export PATH=$(echo "$PATH" | tr ':' '\n' | sort | uniq | tr '\n' ':')
    _ok "Duplicate PATH segments removed"
  else
    _ok "No duplicate PATH segments found â€” all good."
  fi

  # âœ… Optional CLI tools using probes
  _info "Optional CLI tools check"
  probe "Terraform CLI" true "(optional)"
  probe "kubectl CLI"   true "(optional)"
  probe "Helm CLI"      true "(optional)"

else
  _info "âœ¨  Direnv not installed â€” skipping"
fi

# âœ… Colima detection (optional)
_info "Colima not applicable on Linux â€” skipping"

###############################################################################
# â–‘â–‘  PATH SANITY
###############################################################################
_divider; _info "ğŸ›£  PATH SANITY"

check "~/.local/bin present" \
      'grep -q "$HOME/.local/bin" <<<"$PATH"' \
      "(prepend to PATH)" \
      'echo "export PATH=\"$HOME/.local/bin:\$PATH\"" >> ~/.zshrc'

###############################################################################
# â–‘â–‘  GIT
###############################################################################
if has git && git rev-parse --is-inside-work-tree &>/dev/null; then
  _divider; _info "ğŸ”§  GIT BASICS"

  check "git available"      'git --version'
  check "git user.name set"  'git config --global user.name' \
        "(git config --global user.name â€¦)"
  check "git user.email set" 'git config --global user.email' \
        "(git config --global user.email â€¦)"

  # âœ… Repo sync not enforced in local-only mode
  _info "repo in sync check skipped â€” local-only mode"
else
  _info "ğŸ”§  Not in a git repo â€” skipping repo checks"
fi

###############################################################################
# â–‘â–‘  DOCKER / CLOUD CLI
###############################################################################
_divider; _info "ğŸ³  DOCKER & CLOUD"

# For macOS: Check Docker Desktop status
if [[ "$OSTYPE" == "darwin"* ]]; then
  if ! docker info &>/dev/null; then
    _warn "Docker is not running. Please start Docker Desktop."
  else
    _ok "Docker Desktop is running"
  fi
fi

# For Linux: Start Docker service if not running
if [[ "$OSTYPE" == "linux-gnu"* ]]; then
  check "Docker daemon"  'docker info &>/dev/null' \
      "(start Docker service)" "sudo systemctl start docker"
fi

check "AWS CLI"        'aws --version' \
      "(apt install awscli or use pipx)" "apt install awscli"
check "gh CLI"         'gh --version' \
      "(apt install gh or use GitHub release)" "apt install gh"

###############################################################################
# â–‘â–‘  DEVOPS / LANG MANAGERS (optional)
###############################################################################
_divider; _info "â˜¸ï¸  EXTRA TOOLING"

# --- Poetry -----------------------------------------------------------------
check "Poetry CLI"  'command -v poetry' \
     "(pipx install poetry)"  "pipx install poetry"

# â€£ Only check the virtual-env when *inside* a Poetry project
if [[ -f pyproject.toml ]] && command -v poetry &>/dev/null; then
  probe "poetry venv OK" 'poetry env info --path >/dev/null'
fi

# --- Terraform / Kubernetes / Helm (optional) -------------------------------
# probe "Terraform CLI" 'command -v terraform' "(optional)"
# probe "kubectl CLI"   'command -v kubectl'   "(optional)"
# probe "Helm CLI"      'command -v helm'      "(optional)"

###############################################################################
# â–‘â–‘  HOMEBREW
###############################################################################
if has brew; then
  _divider; _info "ğŸº  HOMEBREW"

  # â”€â”€ brew doctor (give it max 15s so the script never hangs) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  _info "brew doctor clean"
  if _brew_doctor_ok; then
    _ok "OK"
  else
    _warn "WARN (run: brew doctor)"
  fi

  # â”€â”€ security-critical upgrades (skip when --fast or jq missing) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if has jq; then
    (( FAST )) || brew update --quiet &>/dev/null || true   # silent refresh

    sec_up=$(
      { HOMEBREW_NO_AUTO_UPDATE=1 \
        brew outdated --greedy --json=v2 2>/dev/null || true; } |
      jq '[ (.formulae[]?.name // empty)
            ,(.casks[]?.token // empty) ]          # collect all names
          | map(select(test("-security$")))        # keep *-security packages
          | length'
    )

    check "no pending security upgrades" \
          "[[ ${sec_up:-0} -eq 0 ]]" "($sec_up security updates)" \
          "brew upgrade --greedy"
  else
    _warn "jq missing â€” skipping security-upgrade scan"
  fi

  # â”€â”€ disable phone-home analytics â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  check "brew analytics off" \
        'brew analytics 2>/dev/null | grep -qEi "analytics.*disabled|destroyed"' \
        "(brew analytics off)" "brew analytics off"
fi

###############################################################################
# â–‘â–‘  pre-commit config
###############################################################################
check "pre-commit config valid" \
      '[[ ! -f .pre-commit-config.yaml || $(pre-commit validate-config -q && echo ok) ]]' \
      "(missing or invalid file)"

###############################################################################
# â–‘â–‘  DIR ENV AUDIT MODE
###############################################################################
if [[ "${1:-}" == "--direnv-audit" || "${1:-}" == "-da" ]]; then
  _divider
  _info "ğŸ“¦ Direnv Audit: Scanning ~/projects/*/.direnv â€¦"

  for d in ~/projects/*/.direnv; do
    [[ -d "$d" ]] || continue

    project=$(basename "$(dirname "${d:-/dev/null}")")
    envrc="${d:-/dev/null}"; envrc="${envrc%/.direnv}/.envrc"

    printf '%-30s' "${project:-<unknown>}"

    if [[ -f "$envrc" ]]; then
      if bash -n "$envrc" &>/dev/null; then
        venv_line=$(grep -E "layout python|source venv/bin/activate" "$envrc" | head -n 1)
        if [[ -n "${venv_line:-}" ]]; then
          echo "${GRN}âœ… .envrc valid / Venv: âœ…${RST}"
        else
          echo "${YLW}âœ… .envrc valid / Venv: âŒ${RST}"
        fi
      else
        echo "${RED}âŒ .envrc invalid syntax${RST}"
      fi
    else
      echo "${RED}âŒ .envrc missing${RST}"
    fi
  done

  _divider
  _info "ğŸ§¹ Largest .direnv folders by size:"
  du -sh ~/projects/*/.direnv 2>/dev/null | sort -hr | head -n 10 | awk '{printf "  %s\t%s\n", $1, $2}'

  exit 0
fi

###############################################################################
# â–‘â–‘  BENCHMARKS
###############################################################################
if (( BENCH )); then
  SHELL_TIME=$(( $(date +%s%3N) - ${ZSH_START_TIME:-0} ))
  SCRIPT_TIME=$(( $(date +%s%3N) - START_TS ))
  _divider; _info "â±  TIMINGS"
  check "shell startup <500 ms"   "[[ $SHELL_TIME  -lt 500 ]]"  "(slow: ${SHELL_TIME} ms)"
  check "sanity runtime <2000 ms" "[[ $SCRIPT_TIME -lt 2000 ]]" "(${SCRIPT_TIME} ms)"
fi

###############################################################################
# â–‘â–‘  Summary / exit codes
###############################################################################
_divider
if   (( FAILED )); then
  echo -e "${RED}âœ– Some checks FAILED${RST}"
  exit 2                    # hard failure
elif (( WARNED )); then
  echo -e "${YLW}â–² Completed with WARNs${RST}"
  exit 1                    # soft warnings
else
  echo -e "${GRN}âœ” All good${RST}"
  exit 0                    # perfect score
fi
